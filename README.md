# Fast Distance Multiplication для LCS

## Обзор задачи

Дана задача поиска наибольшей общей подпоследовательности (LCS) для двух строк. Классический алгоритм работает за O(n·m). Цель – модифицировать алгоритм так, чтобы после затратной предобработки можно было отвечать на запросы для любых двух префиксов строк за O(1).

## Основная идея

Мы сводим задачу LCS к задаче минимизации стоимости через преобразование динамического программирования. Вводится функция стоимости F(i, j):

**F(i, j) = i + j – 2 · LCS(i, j)**

с граничными условиями:
- F(0, j) = j
- F(i, 0) = i

Затем определим вспомогательную функцию X(i, j):
- **X(i, j) = F(i, j) – j = i – 2 · LCS(i, j)**

Отсюда следует, что:
- **LCS(i, j) = (i + j – F(i, j)) / 2 = (i – X(i, j)) / 2**

## Предобработка через Fast Distance Multiplication

Для ускорения обработки запросов мы используем fast distance multiplication. Основные этапы:

1. **Построение переходных матриц**  
   Для каждого символа *c* исходной строки *s* строится матрица D(c) размерности (m+1)×(m+1) (где m = |t|). Эти матрицы моделируют элементарные шаги динамики:
   - **Вертикальный переход:** При j = k задаётся стоимость равная 1.
   - **Диагональный переход:** Если c совпадает с t[k], то для j = k+1 задаётся стоимость 0 (бесплатный шаг); иначе – 2.
   - **Горизонтальные переходы:** Для j > k+1 задаются стоимости в зависимости от того, совпадает c с t[k] или нет:
     - При совпадении: стоимость = (j – k – 1)
     - При несовпадении: стоимость = (j – k – 1) + 2 = j – k + 1.
   - Для k = m (конечное состояние) задаётся D(c)[m, m] = 1.

2. **Произведение матриц**  
   Для исходной строки *s* вычисляется произведение:

   
   $$
   P[i] = D(s_1) \otimes D(s_2) \otimes \dots \otimes D(s_i)
   $$
   
   где операция "distance multiplication" определяется как минимум по промежуточным состояниям. Для корректности (при наличии отрицательных значений) используется наивное перемножение.

4. **Формирование итогового массива**  
   После вычисления произведения для каждого i формируется массив:
   
   **m_Q[i][j] = min(0 ≤ k ≤ m) { k + P[i](k, j) }**
   
   Это значение соответствует X(i, j) = F(i, j) – j. Граничные условия обеспечиваются явной установкой:
   - m_Q[0][j] = j (так как F(0,j)=j)
   - m_Q[i][0] = i (так как F(i,0)=i)

## Вычисление LCS (функция Query)

После предобработки, для любого запроса, задающего префиксы s[0..p-1] и t[0..q-1], LCS вычисляется по формуле:

$$
\mathrm{LCS}(p,q) = \frac{p + q - m\_Q[p][q]}{2}
$$

Так как все значения динамики сохранены в массиве m_Q, функция Query выполняется за O(1).

## Обработка крайних случаев

- **Пустые префиксы:** Если хотя бы один из префиксов пуст (p ≤ 0 или q ≤ 0), функция Query возвращает LCS = 0.
- **Граничные условия:** Мы гарантируем, что для любого i выполняется m_Q[i][0] = i и для i = 0 выполняется m_Q[0][j] = j.
- **Корректность для малых входов:** При корректном выборе коэффициентов в D(c) и восстановлении граничных условий:
  - Например, для s = "a" и t = "a" → Query(1,1) = 1.
  - Для s = "abc" и t = "abc" → Query(3,3) = 3.
  - Для 100 одинаковых символов → Query(100,100) = 100.

## Итоговая структура проекта

Проект разделён на следующие модули:

- **MatrixUtils:**  
  Определяет тип Matrix, константу kInf, функцию CreateIdentity и операцию DistanceMultiply (наивное перемножение матриц).

- **TransitionMatrix:**  
  Содержит функцию CreateTransitionMatrix, которая по символу c и строке t строит переходную матрицу D(c), моделирующую вертикальные, диагональные и горизонтальные переходы.

- **LCSQuery:**  
  Основной класс, который:
  - Выполняет предобработку (вычисляет произведение переходных матриц для префиксов строки s и формирует итоговый массив m_Q).
  - Предоставляет метод Query, который возвращает LCS для заданных префиксов за O(1).

## Победа над проблемами

В ходе разработки возникали следующие проблемы:
- **Неправильная обработка граничных условий:** Ранее значения для пустых префиксов не соответствовали ожиданиям. Это решено явной установкой m_Q[i][0] = i.
- **Корректировка коэффициентов в D(c):** Неверно подобранные коэффициенты приводили к неправильному снижению стоимости при диагональных переходах. В итоговой схеме при совпадении диагональный переход имеет стоимость 0, а при несовпадении – 2.
- **Обработка отрицательных значений:** Использование наивного перемножения матриц позволило корректно обрабатывать отрицательные стоимости.
- **Быстрый ответ:** После предобработки все значения динамики сохраняются в m_Q, что позволяет отвечать на запросы за O(1).

## Заключение

Решение сводит задачу LCS к задаче минимизации стоимости через преобразование F(i, j) = i + j – 2·LCS(i, j). Переходные матрицы D(c) моделируют изменения стоимости при обработке каждого символа, а последовательное перемножение этих матриц и явное восстановление граничных условий позволяет предобработать динамику и сохранить её в массиве m_Q. Итоговая функция Query возвращает LCS для заданных префиксов по формуле:

$$
\mathrm{LCS}(p,q) = \frac{p + q - m\_Q[p][q]}{2}
$$

что обеспечивает ответ за O(1) после затратной предобработки.
