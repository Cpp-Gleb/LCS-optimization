# Fast Distance Multiplication of Unit-Monge Matrices for LCS

## Обзор задачи

Дана задача нахождения наибольшей общей подпоследовательности (LCS) для двух строк. Классический алгоритм динамического программирования работает за $` (O(n \cdot m)) `$ . Цель нашего решения — провести затратную предобработку и затем отвечать на запросы для любых двух префиксов строк за \(O(1)\).

## Преобразование LCS в задачу минимизации стоимости

Мы преобразуем задачу LCS с помощью следующего определения:
  
- **F(i, j) = i + j – 2 · LCS(i, j)**

с граничными условиями:
- \(F(0, j) = j\)
- \(F(i, 0) = i\)

Введём вспомогательную функцию:
  
- **X(i, j) = F(i, j) – j = i – 2 · LCS(i, j)**

Отсюда получаем:

  $$
  LCS(i, j) = \(\frac{i + j - F(i,j)}{2}\) = \(\frac{i - X(i,j)}{2}\)
  $$


## Использование Fast Distance Multiplication

### Переходные матрицы D(c)

Для каждого символа **c** строки **s** строится переходная матрица **D(c)** размерности ((m+1) x (m+1)), где (m = |t|). Эти матрицы моделируют изменение стоимости при обработке одного символа, и мы определяем их следующим образом для каждого состояния (0 ≤ k < m\):

- **Вертикальный переход:**  
  Если \(j = k\), то \(D(c)[k, k] = 1\) (штраф за отсутствие продвижения по строке **t**).

- **Диагональный переход:**  
  Если \(j = k+1\):
  - Если \(c\) совпадает с \(t[k]\), то \(D(c)[k, k+1] = 0\) (бесплатный шаг по диагонали при совпадении).
  - Если \(c\) не совпадает с \(t[k]\), то \(D(c)[k, k+1] = 2\) (штраф за несоответствие).

- **Горизонтальные переходы:**  
  Если \(j > k+1\):
  - При совпадении: \(D(c)[k, j] = (j - k - 1)\).
  - При несовпадении: \(D(c)[k, j] = (j - k - 1) + 2 = j - k + 1\).

Для состояния \(k = m\) (конечное состояние) устанавливается \(D(c)[m, m] = 1\).

### Предобработка через перемножение матриц

Для строки **s** вычисляем произведение переходных матриц:

$$
P[i] = D(s_1) \otimes D(s_2) \otimes \cdots \otimes D(s_i)
$$

где операция **distance multiplication** определяется как:

$$
(A \otimes B)[i, j] = \min_{k} \{ A[i, k] + B[k, j] \}.
$$

## Метод "муровья" (AntMethod)

Чтобы ускорить перемножение матриц, используем метод разделяй и властвуй для поиска минимумов по строкам в unit‑Monge матрицах. Данный метод, называемый **AntMethod**, использует монотонность оптимальных индексов: если для фиксированной строки оптимальный индекс для столбца \(j\) равен \(k\), то для столбца \(j+1\) оптимальный индекс не меньше \(k\). Это свойство позволяет рекурсивно разделять диапазоны столбцов и находить минимум за время \(O(d)\) для одной строки (при размерности матрицы $` (d \times d) `$ ), что снижает асимптотику перемножения матриц с \(O(d^3)\) до примерно \(O(d^2)\) на строку. В совокупности, для умножения \(n\) матриц это приводит к улучшенной предобработке примерно до $` (O(n \cdot m \cdot \log(n \cdot m))) `$ .

## Формирование итогового массива стоимости

После вычисления произведений \(P[i]\) для каждого префикса строки **s** формируется массив:

$$
m\_Q[i][j] = \min_{0 \le k \le m}\{ k + P[i](k, j) \}.
$$

Это значение соответствует \(X(i, j) = F(i,j) - j\). Мы также явно устанавливаем граничное условие:

$$
(m\_Q[i][0] = i\) (так как \(F(i, 0)=i\))
$$


## Функция Query

После предобработки для любого запроса, задающего префиксы $` (s[0 \ldots p-1]) `$ и $` (t[0 \ldots q-1]) `$ , LCS вычисляется по формуле:

$$
\mathrm{LCS}(p, q) = \frac{p + q - m\_Q[p][q]}{2}
$$

Поскольку массив \(m\_Q\) предвычислен, ответ на запрос получается за \(O(1)\).

## Резюме 

- **Преобразование:**  
  Мы переопределили динамику LCS через функцию $` (F(i,j)= i+j-2\cdot \mathrm{LCS}(i,j)) `$ и вспомогательную $` (X(i,j)=F(i,j)-j) `$ , что позволяет выразить LCS как $` ((i - X(i,j))/2) `$ .

- **Переходные матрицы D(c):**  
  Для каждого символа исходной строки создаётся матрица, моделирующая вертикальные, диагональные и горизонтальные переходы, с выбранными коэффициентами (стоимость 1 для вертикального шага, 0 или 2 для диагонального в зависимости от совпадения, и соответствующие стоимости для горизонтальных переходов).

- **AntMethod:**  
  Оптимизированный метод разделяй и властвуй для поиска минимумов в строках unit‑Monge матриц. Благодаря этому алгоритму перемножение двух матриц выполняется за \(O(d^2)\) вместо \(O(d^3)\). При последовательном перемножении \(n\) матриц предобработка достигается за примерно $` (O(n \cdot m \cdot \log(n \cdot m))) `$ .

- **Предобработка и быстрый ответ:**  
  После предобработки, значения динамики сохраняются в массиве \(m\_Q\), что позволяет отвечать на запросы LCS за \(O(1)\) по формуле:

$$
  \mathrm{LCS}(p, q)=\frac{p+q - m\_Q[p][q]}{2}
$$

- **Обработка крайних случаев:**  
  Мы явно задаём граничные условия (например, \(m\_Q[i][0] = i\) и \(m\_Q[0][j]=j\)) для корректного обращения с пустыми префиксами.

## Заключение

Алгоритм **Fast Distance Multiplication of Unit-Monge Matrices** с использованием метода "муровья" (AntMethod) позволяет оптимизировать перемножение переходных матриц в задаче LCS. За счёт использования монотонности оптимальных индексов и рекурсивного разделения диапазонов столбцов удаётся снизить асимптотику перемножения, что приводит к улучшению предобработки до примерно $` (O(n \cdot m \cdot \log(n \cdot m))) `$. После предобработки, ответы на запросы вычисляются за \(O(1)\).
