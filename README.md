# LCS-optimization

В этой задаче даны две строки, для которых мы хотим решать задачу наибольшей общей подпоследовательности (LCS). Давайте модифицируем задачу так, чтобы можно было отвечать на запросы для любых двух префиксов строк за \(O(1)\).

---

## Сведение задачи LCS к минимизации стоимости

В этом решении задача наибольшей общей подпоследовательности (LCS) сводится к задаче минимизации «стоимости».

$$
A(i,j) = i + j - 2 \times LCS(i,j)
$$

которая удовлетворяет рекуррентному соотношению

$$
A(i,j) = \min \{\, A(i-1,j) + 1,\; A(i,j-1) + 1,\; A(i-1,j-1) + \delta(i,j) \},
$$

где

$$
\delta(i,j) =
\begin{cases}
0, & \text{если } s[i-1] = t[j-1], \\
2, & \text{иначе}.
\end{cases}
$$

При этом базовые значения таковы:

$$
A(0,j) = j \quad (\text{аналогично по строкам}).
$$

---

## Переходная матрица

Для обработки одного символа строки \(s\) вводится так называемая «переходная матрица» \(D(s)\) размером \((m+1) x (m+1)\), где \(m = |t|\).

Смысл этой матрицы — описать, как изменяется стоимость \(A\) при обработке одного символа \(s\). После этого можно записать:

$$
A(i,\cdot) = A(0,\cdot) \otimes D(s_1) \otimes D(s_2) \otimes \dots \otimes D(s_i),
$$

где операция «distance multiplication» для матриц \(X\) и \(Y\) определяется как

$$
(X \otimes Y)[i][j] = \min_{0 \le k \le m} \bigl( X[i][k] + Y[k][j] \bigr).
$$

Так как базовый вектор \(A(0,j) = j\) известен, отвечая на запрос для префиксов \(s[0 \ldots i-1]\) и \(t[0 \ldots j-1]\), получаем

$$
LCS(i,j) = \frac{i + j - A(i,j)}{2}
= \frac{i + j - \Bigl(j + \min_{0 \le k \le m} \bigl( k + (D(s_1) \otimes \dots \otimes D(s_i))[k][j] \bigr)\Bigr)}{2}
= \frac{i - Q[i][j]}{2},
$$

где обозначили

$$
Q[i][j] = \min_{0 \le k \le m} \bigl( k + P[i][k][j] \bigr),
\quad
P[i] = D(s_1) \otimes D(s_2) \otimes \dots \otimes D(s_i).
$$

---

## Ключевые моменты решения

### 1. Переходная матрица для одного символа \(s\)

Пусть \(c\) — символ строки \(s\). Строка \(t\) имеет длину \(m\). Тогда матрица \(D(c)\) имеет размер \((m+1) x (m+1)\). Если рассматривать состояние с индексом \(k\) как «количество уже сопоставленных символов из \(t\)», то:

- **Если не производится сопоставление:**  
  Переход осуществляется из состояния с индексом \(k\) в состояние, где индекс \(j\) не меньше \(k\), со стоимостью
  (1 + (j - k))
  (вертикальный переход плюс горизонтальные сдвиги).

- **Если \(k < m\) и \(c = t[k]\):**  
  Можно выполнить диагональный переход: перейти из состояния \(k\) в состояние \(k+1\) без дополнительной стоимости, а затем горизонтально — что даёт стоимость
  (j - k - 1)
  при переходе в состояние, где индекс \(j\) не меньше \(k+1\).


Таким образом, определяем:

$$
D(c)[k][j] =
\begin{cases}
\infty, & \text{если } j < k, \\
1, & \text{если } j = k, \\
\min \{\, 1 + (j-k),\; (j-k-1) \}, & \text{если } j > k \text{ и } k < m \text{ и } c = t[k], \\
1 + (j-k), & \text{если } j > k \text{ в остальных случаях.}
\end{cases}
$$

### 2. Операция distance multiplication

Для двух матриц \(A\) и \(B\) необходимо вычислить

$$
C[i][j] = \min_{0 \le k \le m} \bigl( A[i][k] + B[k][j] \bigr).
$$

Благодаря свойству unit‑Monge (монотонности оптимальных индексов) можно ускорить вычисление с помощью метода «двойного указателя». Это позволяет перемножать матрицы размера \((m+1) x (m+1)\) за \(O(m^2)\).

### 3. Пре-вычисление префиксного произведения

Пусть \(n = |s|\) и \(m = |t|\). Вычисляем массив \(P[\,0 \ldots n]\) по формуле:

$$
P[0] = I, \qquad
P[i] = P[i-1] \otimes D(s[i-1]).
$$

Затем для каждого \(i\) предвычисляем вектор \(Q[i]\) по формуле:

$$
Q[i][j] = \min_{0 \le k \le m} \bigl( k + P[i][k][j] \bigr).
$$

При этом итоговая стоимость определяется как

$$
A(i,j) = j + Q[i][j]
\quad (\text{ведь } A(0,j) = j).
$$

Следовательно,

$$
LCS(i,j) = \frac{i + j - A(i,j)}{2} = \frac{i + j - \bigl(j + Q[i][j]\bigr)}{2} = \frac{i - Q[i][j]}{2}.
$$  

---

## Ассимптотика

- **Перемножение матриц:** для каждой буквы строки \(s\) перемножаются матрицы размера \((m+1) x (m+1)\) за \(O(m^2)\).
- **Предобработка:** занимает \(O(n x m^2)\).
- **Предвычисление векторов \(Q[i]\):** занимает \(O(n x m^2)\).
- **Ответ на запрос:** каждый запрос для префиксов обрабатывается за \(O(1)\).

Таким образом, данный подход позволяет эффективно отвечать на запросы по префиксам строк, используя предобработку переходных матриц и векторов.
